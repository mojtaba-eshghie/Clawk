require('module-alias/register');
const fs = require('fs');
const path = require('path');
const assert = require('assert');
const chalk = require('chalk');
const { 
    extractSolcVersion, 
    compileWithVersion, 
    deployContract,
    getContractABI,
} = require('@lib/web3/deploy');
const setupAvalancheEnv = require('@envs/avalanche-subnet');
const setupAnvilEnv = require('@envs/anvil');
const deployBridge = require('@envs/bridge-decentralized');
const { sleep } = require('@lib/os/process');
const Monitor = require('@monitor/multi-chain-monitor');
const getLogger = require('@lib/logging/logger').getLogger;
const bridgeTestLogger = getLogger('bridgetest');
const { getActivities } = require('@lib/dcr/info');

async function sequence(contractsA, contractsB, web3A, web3B){

    let tokenA = contractsA.token;
    let vaultA = contractsA.vault;
    let routerA = contractsA.router;
    let oracleA = contractsA.oracle;

    let tokenB = contractsB.token;
    let vaultB = contractsB.vault;
    let routerB = contractsB.router;
    let oracleB = contractsB.oracle;


    let accountA = web3A.eth.accounts.wallet[0].address;
    let accountB = web3B.eth.accounts.wallet[0].address;
    console.log(vaultA._address);

    //Add exchange rates
    let addTrustedOnOracleA = await oracleA.methods.addTrustedSource(accountA).send({
        from: accountA,
        gas: 300000
    });
    let addAvaxValueOnA = await oracleA.methods.submitPrice("B.AVAX", 400).send({
        from: accountA,
        gas: 300000
    });
    let addERC20ValueOnAA = await oracleA.methods.submitPrice("A." + tokenA._address, 2000).send({
        from: accountA,
        gas: 300000
    });
    let addERC20ValueOnAB = await oracleA.methods.submitPrice("B." + tokenB._address, 2000).send({
        from: accountA,
        gas: 300000
    });


    let addTrustedOnOracleB = await oracleB.methods.addTrustedSource(accountB).send({
        from: accountB,
        gas: 300000
    });
    let addAvaxValueOnB = await oracleB.methods.submitPrice("A.ETH", 2500).send({
        from: accountB,
        gas: 300000
    });
    let addERC20ValueOnBA = await oracleB.methods.submitPrice("A." + tokenA._address, 5000).send({
        from: accountB,
        gas: 300000
    });
    let addERC20ValueOnBB = await oracleB.methods.submitPrice("B." + tokenB._address, 5000).send({
        from: accountB,
        gas: 300000
    });

    let fundTarget = await vaultB.methods.fund().send({
        from: accountB,
        gas: 300000,
        value: 100000
    });
    if(!fundTarget.status){
        console.log(fundTarget);
    }

    let balance = await web3B.eth.getBalance(vaultB._address); 
    console.log(balance);

    let expiry = Math.floor(Date.now() / 1000) + 100;
    console.log(expiry);

    let receipt1 = await routerA.methods.eth_depositWithExpiry(vaultA._address, "0x0000000000000000000000000000000000000000", 0, "SWAP:B.AVAX:" + accountB, expiry).send({
        from: accountA,
        gas: 300000,
        value: 100
    });

    await sleep(5000);

    let balance2 = await web3B.eth.getBalance(vaultB._address); 
    console.log(balance2);
    assert(balance2 == 99750, "Value was not 99750 as expected: " + balance2);
    return balance2 == 99750;
}

async function callSmartContract(method, sender, value = 0){
    let receipt = await method.send({
        from: sender,
        gas: 300000,
        value: value
    });
}

async function startUp() {
    
    console.log(chalk.cyan(`exploit 2`));

    bridgeTestLogger.debug("Starting Anvil...");
    
    const maxRetries = 10;
    let attempts = 0;
    let envAnvil;

    while (attempts < maxRetries) {
        try {
            await sleep(1000);
            envAnvil = await setupAnvilEnv();
            bridgeTestLogger.debug('Environment setup successful:', envAnvil);
            break;
        } catch (error) {
            bridgeTestLogger.debug(`Attempt ${attempts + 1}: Failed to set up environment - ${error}`);
            console.error(`Attempt ${attempts + 1}: Failed to set up environment - ${error}`);
            attempts++;
            if (attempts === maxRetries) {
                console.error('Max retries reached, failing with error');
                bridgeTestLogger.error('Max retries reached, failing with error');
                throw error; // Optionally re-throw the last error after max retries
            }
        }
    }
    
    bridgeTestLogger.debug("Finished running Anvil...");

    bridgeTestLogger.debug("Starting Avalanche...");
    let envAvalanche = await setupAvalancheEnv(); 
    bridgeTestLogger.debug("Finished running Avalanche");

    bridgeTestLogger.debug("Web3 A: " + envAnvil.envInfo.rpcAddress);
    bridgeTestLogger.debug("Web3 B: " + envAvalanche.envInfo.rpcAddress);

    let contractsA = await deployBridge(envAnvil.web3, envAnvil.envInfo, 'A', 'ETH', 'EthRouter', 'EthVaultOracle', 'Oracle', 'eth_bridgeForwards', 'eth_bridgeForwardsERC20', 11000);
    let contractsB = await deployBridge(envAvalanche.web3, envAvalanche.envInfo, 'B', 'AVAX', 'AvaxRouter', 'AvaxVaultOracleVulnerability2', 'Oracle', 'avax_bridgeForwards', 'avax_bridgeForwardsERC20', 11000);

    let routerSourceA = fs.readFileSync(path.join('contracts', 'src', 'cross-chain', 'EthRouter.sol'), 'utf8');
    let routerABIA = await getContractABI(routerSourceA, 'EthRouter', 'EthRouter');

    let vaultSourceA = fs.readFileSync(path.join('contracts', 'src', 'cross-chain', 'EthVaultOracle.sol'), 'utf8');
    let vaultABIA = await getContractABI(vaultSourceA, 'EthVaultOracle', 'EthVaultOracle');

    let routerSourceB = fs.readFileSync(path.join('contracts', 'src', 'cross-chain', 'AvaxRouter.sol'), 'utf8');
    let routerABIB = await getContractABI(routerSourceB, 'AvaxRouter', 'AvaxRouter');

    let vaultSourceB = fs.readFileSync(path.join('contracts', 'src', 'cross-chain', 'AvaxVaultOracleVulnerability2.sol'), 'utf8');
    let vaultABIB = await getContractABI(vaultSourceB, 'AvaxVaultOracleVulnerability2', 'AvaxVaultOracleVulnerability2');

    // Let's start the monitor here
    let configs = {
        "contracts": [{
            web3: envAnvil.web3,
            contractAddress: contractsA.vault._address,
            contractFileName: 'EthVaultOracle',
            contractName: 'EthVaultOracle',
            contractABI: vaultABIA,
            modelFunctionParams: null,
        },
        {
            web3: envAnvil.web3,
            contractAddress: contractsA.router._address,
            contractFileName: 'EthRouterVulnerability1',
            contractName: 'EthRouterVulnerability1',
            contractABI: routerABIA,
            modelFunctionParams: null,
        },
        {
            web3: envAvalanche.web3,
            contractAddress: contractsB.vault._address,
            contractFileName: 'AvaxVaultOracle',
            contractName: 'AvaxVaultOracle',
            contractABI: vaultABIB,
            modelFunctionParams: null,
        },
        {
            web3: envAvalanche.web3,
            contractAddress: contractsB.router._address,
            contractFileName: 'AvaxRouter',
            contractName: 'AvaxRouter',
            contractABI: routerABIB,
            modelFunctionParams: null,
        }],
        activities: await getActivities(1823976),
        modelId: 1823976,
        hasResponseRelation: true,
        modelName: "CrossChainDEX",
    };
    let monitor = new Monitor(configs);

    monitor.on('statusChange', async (newStatus) => {
        if (newStatus === 'INITIALIZED') {
            bridgeTestLogger.debug(`Monitor is initialized...`);                          
            monitor.start();
        } else if (newStatus == 'RUNNING') {
            bridgeTestLogger.debug("Executing sequence");
            let execution = await sequence(contractsA, contractsB, envAnvil.web3, envAvalanche.web3);
            bridgeTestLogger.debug("Done");
        }
    });     
}
//startUp();

module.exports = startUp;